---
title: "GDAT626 Final Project"
author: "James Stanfield"
date: "12/6/2019"
output: word_document
---

#Setup:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

c("data.table",
  "haven",         #read dta files
  "here",
  "recipes",       #recipe and bake
  "ggplot2",
  "glue",          #tidyverse-type package
  "cowplot",       #visualizations
  "tidyquant",     #theme_tq
  "timetk",        #tk_index
  "tibbletime",    #as_tbl_time
  "TTR",           # decompose
  "lubridate",     # Excellent for manipulating and converting to and from 'date' data
  "tidyverse",     # For data manipulation
  "lattice",       # xyplot to look for effect of groups
  "dtplyr",        # Pipes (%>%), mutate, etc.
  "car",           # scatterplot
  "stats",         # cor
  "forecast",      # forecasting
  "here",          # Better folder structure
  "MASS",          # fitdistr()
  "MTS",           # Multivariate time series
  "plotly",        # For 3-d and interactive plots
  "dtw",           # dynamic time warping
  "tseries",       # Some time series functions
  "xts",           # More time series functions
  "zoo",           # Still more time series functions
  "tsfeatures",    # package contsaing functions for identifying features of time series
  "keras",         # converts code for machine learning using python
  "rsample",       # commands fro creating test/train data splits
  "TSA"            # periodogram
  ) -> package_names  
for(package_name in package_names) {
  if(!is.element(package_name, installed.packages()[,1])) {
     install.packages(package_name,
                      repos = "http://cran.mtu.edu/")
  }
  library(package_name, character.only=TRUE,
          quietly=TRUE,verbose=FALSE)
}

rm(list=c("package_name", "package_names")) # clean up the environment

options(show.signif.stars = FALSE)  # Don't confuse significance & effect size!

set_here()  # So that this works anywhere

set.seed(42)
```
```{r session}
sessionInfo()       # Information about all the packages and versions
Sys.time()          # So we have a record of when this was knit
```

#Topic

#Data

1/14/2011 to 6/3/2011

###Load Data

```{r Load_Dow_Jones_data}
#fread {data.table} command for smartly reading in data in multiple formats, such as csv or txt

fread("C:/Users/Richard/Documents/Data Science/GDAT_626_Time-series/DOW_JONES/dow_jones_index.data") -> Dow_Jones

str(Dow_Jones)
```

###Data Cleaning

```{r remove_$_Convert_to_numeric}
#Remove dollar sign from Dow_Jones
gsub('\\$', '', Dow_Jones$high) -> Dow_Jones$high #\\ "escape" the character
as.numeric(Dow_Jones$high) -> Dow_Jones$high

gsub('\\$', '', Dow_Jones$open) -> Dow_Jones$open #\\ "escape" the character
as.numeric(Dow_Jones$open) -> Dow_Jones$open

gsub('\\$', '', Dow_Jones$close) -> Dow_Jones$close #\\ "escape" the character
as.numeric(Dow_Jones$close) -> Dow_Jones$close

gsub('\\$', '', Dow_Jones$low) -> Dow_Jones$low #\\ "escape" the character
as.numeric(Dow_Jones$low) -> Dow_Jones$low

gsub('\\$', '', Dow_Jones$next_weeks_open) -> Dow_Jones$next_weeks_open #\\ "escape" the character
as.numeric(Dow_Jones$next_weeks_open) -> Dow_Jones$next_weeks_open

gsub('\\$', '', Dow_Jones$next_weeks_close) -> Dow_Jones$next_weeks_close #\\ "escape" the character
as.numeric(Dow_Jones$next_weeks_close) -> Dow_Jones$next_weeks_close

head(Dow_Jones)
```

```{r select_open}
select(Dow_Jones, date, stock, open) -> djData
str(djData)
```


```{r spread_data}
#We want to be able to compare the diferent stocks to each other, so we will spread {tidyr} them out.
spread(djData, key = stock, value = open) %>%       #We kept date in the previous step, so we could successfully spread
  select(., -date) -> djWide                        #We don't need date anymore, so we can drop it
head(djWide)
```

#EDA

###Cluster Denrogram

```{r cor_dj}
cor(djWide, djWide, 
    method = "pearson",
    use = "pairwise.complete.obs") -> djCor
which(is.na(djCor))
```


```{r convert_distance_dj}
1 - djCor * djCor -> djR2dist
as.dist(djR2dist) -> djR2.dist
```

```{r hclust_dj}
hclust(djR2.dist, method = "average") -> djClust

plot(djClust)
```

We'll pick out MRK, HPQ, JPM, and AA for a closer look.

###MRK

```{r TS_Decompose_MRK}
MRK.data <- select(djWide, MRK)
MRK.TS <- ts(MRK.data, frequency = 4) #since we only have 25 weeks, we'll look use periods of a month

decompose(MRK.TS) -> MRK.comp
plot(MRK.comp)
```

```{r acf_MRK}
acf(MRK.TS) #acf {stats} computes estimates of the autocovariance or autocorrelation function
```

```{r pacf_MRK}
pacf(MRK.TS) ##pacf {stats} computes estimates of the partial autocovariance or autocorrelation function
```


###HPQ

```{r TS_Decompose_HPQ}
HPQ.data <- select(djWide, HPQ)
HPQ.TS <- ts(HPQ.data, frequency = 4) #since we only have 25 weeks, we'll look use periods of a month

decompose(HPQ.TS) -> HPQ.comp
plot(HPQ.comp)
```

```{r acf_HPQ}
acf(HPQ.TS) #acf {stats} computes estimates of the autocovariance or autocorrelation function
```

```{r pacf_HPQ}
pacf(HPQ.TS) ##pacf {stats} computes estimates of the partial autocovariance or autocorrelation function
```

###JPM

```{r TS_Decompose_JPM}
JPM.data <- select(djWide, JPM)
JPM.TS <- ts(JPM.data, frequency = 4) #since we only have 25 weeks, we'll look use periods of a month

decompose(JPM.TS) -> JPM.comp
plot(JPM.comp)
```

```{r acf_JPM}
acf(JPM.TS) #acf {stats} computes estimates of the autocovariance or autocorrelation function
```

```{r pacf_JPM}
pacf(JPM.TS) ##pacf {stats} computes estimates of the partial autocovariance or autocorrelation function
```

###AA

```{r TS_Decompose_AA}
AA.data <- select(djWide, AA)
AA.TS <- ts(AA.data, frequency = 4) #since we only have 25 weeks, we'll look use periods of a month

decompose(AA.TS) -> AA.comp
plot(AA.comp)
```

```{r acf_AA}
acf(AA.TS) #acf {stats} computes estimates of the autocovariance or autocorrelation function
```

```{r pacf_AA}
pacf(AA.TS) ##pacf {stats} computes estimates of the partial autocovariance or autocorrelation function
```

#Modeling

###MRK

```{r auto.arima_forecast_MRK}
#auto.arima {forecast} Returns best ARIMA model according to either AIC, AICc or BIC
auto.arima(MRK.TS) -> MRK.arima
  forecast(MRK.arima, level = c(50, 80, 95)) %>% plot()
#forecast {forecast} forecasting from time series or time series models
```

```{r arima_MRK}
MRK.arima
```

According to arima, the best model is a random walk. Since a random walk is the simple prediction that the next point will equal the last point, we can see the forecast running off in a straight, horizontal line

###HPQ

```{r auto.arima_forecast_HPQ}
#auto.arima {forecast} Returns best ARIMA model according to either AIC, AICc or BIC
auto.arima(HPQ.TS) -> HPQ.arima
  forecast(HPQ.arima, level = c(50, 80, 95)) %>% plot()
#forecast {forecast} forecasting from time series or time series models
```

```{r arima_HPQ}
HPQ.arima
```

Another random walk. It's not looking very promising so far.

###JPM

```{r auto.arima_forecast_JPM}
#auto.arima {forecast} Returns best ARIMA model according to either AIC, AICc or BIC
auto.arima(JPM.TS) -> JPM.arima
  forecast(JPM.arima, level = c(50, 80, 95)) %>% plot()
#forecast {forecast} forecasting from time series or time series models
```

```{r arima_MRK}
JPM.arima
```

Now we have something more interesting. The model shows ARIMA(0,1,1)(0,0,1), which indicates a seasonal component to the model.

###AA

```{r auto.arima_forecast_AA}
#auto.arima {forecast} Returns best ARIMA model according to either AIC, AICc or BIC
auto.arima(AA.TS) -> AA.arima
  forecast(AA.arima, level = c(50, 80, 95)) %>% plot()
#forecast {forecast} forecasting from time series or time series models
```

```{r arima_AA}
AA.arima
```

Finally, the model for AA turned out to be an AR model, which predicts a very slight downward trend.

#Evaluate

Lets's take a closer look at the model for JPM.

```{r JPM_model}
forecast(JPM.arima, level = c(50, 80, 95)) %>% plot()
```

Our model predicts a relatively sharp drop the next week, with a fairly level series of values following after

Since this data ends in 2011, I can actaully look up the real-world values that the model is predicting for comparison.

```{r JPM_real_world}
c(43.27, 45.02, 45.21, 43.00, 44.75, 46.00, 47.20, 44.41, 45.62, 45.42, 46.28, 46.81, 46.10, 47.00, 44.27, 44.65, 46.12, 44.75, 42.97, 42.40, 45.94, 41.10, 41.29, 40.50, 43.24, 40.59, 
#I looked up and added the values for the next 8 weeks below, so we could compare predicted to reality  
  40.85, 39.40, 41.51, 40.19, 39.79, 41.52, 41.16, 36.23) -> JPM.real

JPMreal.TS <- ts(JPM.real, frequency = 4)
```

```{r}
forecast(JPM.arima, level = c(50, 80, 95)) %>% plot()
lines(JPMreal.TS, col = "red")
```

That is actually better than I expected. The entirety of the real data is within the 50% CI of the forecast. The model also predicted the placement of a sharp spike down, and the following rise with surprising accuracy, although it underestimated the size of those movements.















